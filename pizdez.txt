####### src/ui/header.rs #########
use crate::app::App;
use ratatui::{prelude::*, widgets::*};

pub fn render(f: &mut Frame, app: &App, area: Rect) {
    let theme = app.theme();
    let date_str = app.date().format();

    let college_info = if let Some(college_name) = app.config.college_name() {
        format!("Колледж: {}", college_name)
    } else {
        format!("Колледж ID: {}", app.config.college_id())
    };

    let campus_info = if let Some(campus_name) = app.config.campus_name() {
        format!("Кампус: {}", campus_name)
    } else {
        format!("Кампус ID: {}", app.config.campus_id())
    };

    let group_info = if let Some(group_name) = app.config.group_name() {
        format!("Группа: {}", group_name)
    } else {
        format!("Группа ID: {}", app.config.group_id())
    };

    let schedule_info = if app.schedules().is_empty() {
        "Нет занятий".to_string()
    } else {
        let lessons_count = app
            .schedules()
            .iter()
            .map(|s| s.lessons.len())
            .sum::<usize>();
        format!("{} занятий", lessons_count)
    };

    let header_text = format!(
        " {} | {} | {} | {} | {} ",
        date_str, college_info, campus_info, group_info, schedule_info
    );

    let header = Paragraph::new(header_text)
        .style(
            Style::default()
                .bg(theme.color("header_bg"))
                .fg(theme.color("header_fg")),
        )
        .alignment(Alignment::Center);

    f.render_widget(header, area);
}
##########################

####### src/ui/mod.rs #########
pub mod header;
pub mod schedule;
pub mod selector;
pub mod setup;

use crate::app::App;
use ratatui::prelude::*;

pub fn render(f: &mut Frame, app: &App) {
    match app.mode() {
        crate::app::AppMode::Normal => render_normal(f, app),
        crate::app::AppMode::Setup(state) => setup::render_setup(f, app, state),
        crate::app::AppMode::Selector(state) => selector::render_selector(f, app, state),
    }
}

fn render_normal(f: &mut Frame, app: &App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(3), Constraint::Min(0)])
        .split(f.area());

    header::render(f, app, chunks[0]);
    schedule::render(f, app, chunks[1]);
}
##########################

####### src/ui/selector.rs #########
use crate::app::App;
use osars::models::{Campus, College, Group};
use ratatui::{prelude::*, widgets::*};

pub enum SelectionStage {
    College,
    Campus,
    Group,
}

pub struct SelectorState {
    pub stage: SelectionStage,
    pub colleges: Vec<College>,
    pub campuses: Vec<Campus>,
    pub groups: Vec<Group>,
    pub selected_index: usize,
    pub selected_college: Option<College>,
    pub selected_campus: Option<Campus>,
    pub error_message: Option<String>,
    pub page: usize,
    pub page_size: usize,
    pub total_items: usize,
}

impl SelectorState {
    pub fn new() -> Self {
        Self {
            stage: SelectionStage::College,
            colleges: Vec::new(),
            campuses: Vec::new(),
            groups: Vec::new(),
            selected_index: 0,
            selected_college: None,
            selected_campus: None,
            error_message: None,
            page: 0,
            page_size: 20,
            total_items: 0,
        }
    }

    pub fn current_items_count(&self) -> usize {
        match self.stage {
            SelectionStage::College => self.colleges.len(),
            SelectionStage::Campus => self.campuses.len(),
            SelectionStage::Group => self.groups.len(),
        }
    }

    pub fn visible_items(&self) -> Vec<ListItem> {
        match self.stage {
            SelectionStage::College => {
                let start = self.page * self.page_size;
                let end = std::cmp::min(start + self.page_size, self.colleges.len());
                self.colleges[start..end]
                    .iter()
                    .enumerate()
                    .map(|(i, college)| {
                        let style = if i == self.selected_index {
                            Style::default().fg(Color::Yellow)
                        } else {
                            Style::default()
                        };
                        ListItem::new(format!("{} (ID: {})", college.name, college.college_id))
                            .style(style)
                    })
                    .collect()
            }
            SelectionStage::Campus => {
                let start = self.page * self.page_size;
                let end = std::cmp::min(start + self.page_size, self.campuses.len());
                self.campuses[start..end]
                    .iter()
                    .enumerate()
                    .map(|(i, campus)| {
                        let style = if i == self.selected_index {
                            Style::default().fg(Color::Yellow)
                        } else {
                            Style::default()
                        };
                        ListItem::new(format!("{} (ID: {})", campus.name, campus.id)).style(style)
                    })
                    .collect()
            }
            SelectionStage::Group => {
                let start = self.page * self.page_size;
                let end = std::cmp::min(start + self.page_size, self.groups.len());
                self.groups[start..end]
                    .iter()
                    .enumerate()
                    .map(|(i, group)| {
                        let style = if i == self.selected_index {
                            Style::default().fg(Color::Yellow)
                        } else {
                            Style::default()
                        };
                        ListItem::new(format!("{} (ID: {})", group.name, group.id)).style(style)
                    })
                    .collect()
            }
        }
    }

    pub fn total_pages(&self) -> usize {
        let total = self.current_items_count();
        if total == 0 {
            1
        } else {
            (total + self.page_size - 1) / self.page_size
        }
    }

    pub fn next_item(&mut self) {
        let visible_count = self.visible_items().len();
        if visible_count > 0 {
            self.selected_index = (self.selected_index + 1) % visible_count;

            if self.selected_index == 0 && self.page < self.total_pages() - 1 {
                self.page += 1;
            }
        }
    }

    pub fn prev_item(&mut self) {
        let visible_count = self.visible_items().len();
        if visible_count > 0 {
            if self.selected_index == 0 && self.page > 0 {
                self.page -= 1;
                self.selected_index = self.visible_items().len() - 1;
            } else {
                self.selected_index = if self.selected_index == 0 {
                    visible_count - 1
                } else {
                    self.selected_index - 1
                };
            }
        }
    }

    pub fn next_page(&mut self) {
        if self.page < self.total_pages() - 1 {
            self.page += 1;
            self.selected_index = 0;
        }
    }

    pub fn prev_page(&mut self) {
        if self.page > 0 {
            self.page -= 1;
            self.selected_index = 0;
        }
    }

    pub fn get_selected_college(&self) -> Option<&College> {
        let start = self.page * self.page_size;
        self.colleges.get(start + self.selected_index)
    }

    pub fn get_selected_campus(&self) -> Option<&Campus> {
        let start = self.page * self.page_size;
        self.campuses.get(start + self.selected_index)
    }

    pub fn get_selected_group(&self) -> Option<&Group> {
        let start = self.page * self.page_size;
        self.groups.get(start + self.selected_index)
    }

    pub fn reset_pagination(&mut self) {
        self.page = 0;
        self.selected_index = 0;
    }
}

pub fn render_selector(f: &mut Frame, app: &App, state: &SelectorState) {
    let theme = app.theme();
    let area = f.area();

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(8),
            Constraint::Length(4),
            Constraint::Length(3),
            Constraint::Length(3),
        ])
        .split(area);

    let title = match state.stage {
        SelectionStage::College => "Выберите колледж",
        SelectionStage::Campus => "Выберите кампус",
        SelectionStage::Group => "Выберите группу",
    };

    let header = Paragraph::new(title)
        .style(Style::default().fg(theme.color("highlight")))
        .alignment(Alignment::Center);
    f.render_widget(header, chunks[0]);

    let list_area = chunks[1];
    let items = state.visible_items();

    let mut list_state = ListState::default();
    list_state.select(Some(state.selected_index));

    let list = List::new(items)
        .block(Block::default().borders(Borders::ALL))
        .highlight_style(Style::default().bg(theme.color("header_bg")));

    f.render_stateful_widget(list, list_area, &mut list_state);

    let info_text = match state.stage {
        SelectionStage::College => "Выберите колледж из списка".to_string(),
        SelectionStage::Campus => format!(
            "Колледж: {}",
            state
                .selected_college
                .as_ref()
                .map_or("Не выбран", |c| &c.name)
        ),
        SelectionStage::Group => format!(
            "Колледж: {}, Кампус: {}",
            state
                .selected_college
                .as_ref()
                .map_or("Не выбран", |c| &c.name),
            state
                .selected_campus
                .as_ref()
                .map_or("Не выбран", |c| &c.name)
        ),
    };

    let info = Paragraph::new(info_text)
        .style(Style::default().fg(theme.color("table_header")))
        .alignment(Alignment::Center);
    f.render_widget(info, chunks[2]);

    let pagination_text = if state.total_pages() > 1 {
        format!(
            "Страница {}/{} ({} элементов) ←→",
            state.page + 1,
            state.total_pages(),
            state.current_items_count()
        )
    } else {
        format!("Всего элементов: {}", state.current_items_count())
    };

    let pagination = Paragraph::new(pagination_text)
        .style(Style::default().fg(theme.color("table_header")))
        .alignment(Alignment::Center);
    f.render_widget(pagination, chunks[3]);

    let help_text = "↑↓: навигация | ←→: страницы | Enter: выбор | Esc: отмена";
    let help = Paragraph::new(help_text)
        .style(Style::default().fg(theme.color("table_header")))
        .alignment(Alignment::Center)
        .block(Block::default().borders(Borders::TOP));
    f.render_widget(help, chunks[4]);

    if let Some(error) = &state.error_message {
        let error_area = Rect {
            x: area.x,
            y: area.y + area.height - 3,
            width: area.width,
            height: 3,
        };
        let error_widget = Paragraph::new(error.as_str())
            .style(Style::default().fg(Color::Red))
            .alignment(Alignment::Center)
            .block(Block::default().borders(Borders::ALL));
        f.render_widget(error_widget, error_area);
    }
}
##########################

####### src/ui/setup.rs #########
use crate::app::App;
use ratatui::{prelude::*, widgets::*};

#[derive(Clone)]
pub struct SetupState {
    pub current_field: usize,
    pub api_url: String,
    pub college_id: String,
    pub campus_id: String,
    pub group_name: String,
    pub error_message: Option<String>,
}

impl SetupState {
    pub fn new() -> Self {
        Self {
            current_field: 0,
            api_url: String::new(),
            college_id: String::new(),
            campus_id: String::new(),
            group_name: String::new(),
            error_message: None,
        }
    }

    pub fn fields_count() -> usize {
        4
    }

    pub fn next_field(&mut self) {
        self.current_field = (self.current_field + 1) % Self::fields_count();
    }

    pub fn prev_field(&mut self) {
        self.current_field = if self.current_field == 0 {
            Self::fields_count() - 1
        } else {
            self.current_field - 1
        };
    }

    pub fn current_field_mut(&mut self) -> &mut String {
        match self.current_field {
            0 => &mut self.api_url,
            1 => &mut self.college_id,
            2 => &mut self.campus_id,
            3 => &mut self.group_name,
            _ => &mut self.api_url,
        }
    }
}

pub fn render_setup(f: &mut Frame, app: &App, state: &SetupState) {
    let theme = app.theme();
    let area = f.area();

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(8),
            Constraint::Length(3),
        ])
        .split(area);

    let header = Paragraph::new("Настройка приложения")
        .style(Style::default().fg(theme.color("highlight")))
        .alignment(Alignment::Center);
    f.render_widget(header, chunks[0]);

    let fields_area = chunks[1];
    let field_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Length(3),
            Constraint::Length(3),
            Constraint::Length(3),
            Constraint::Min(1),
        ])
        .split(fields_area);

    let fields = [
        ("API URL", &state.api_url),
        ("College ID", &state.college_id),
        ("Campus ID", &state.campus_id),
        ("Group Name", &state.group_name),
    ];

    for (i, (label, value)) in fields.iter().enumerate() {
        let is_active = i == state.current_field;
        let style = if is_active {
            Style::default().fg(theme.color("highlight"))
        } else {
            Style::default()
        };

        let input = Paragraph::new(format!("{}: {}", label, value))
            .style(style)
            .block(Block::default().borders(Borders::ALL));

        f.render_widget(input, field_chunks[i]);

        if is_active {
            f.set_cursor_position(Position::new(
                field_chunks[i].x + label.len() as u16 + 2 + value.len() as u16 + 1,
                field_chunks[i].y + 1,
            ));
        }
    }

    if let Some(error) = &state.error_message {
        let error_widget = Paragraph::new(error.as_str())
            .style(Style::default().fg(Color::Red))
            .alignment(Alignment::Center);
        f.render_widget(error_widget, field_chunks[4]);
    }

    let help = Paragraph::new(
        "Enter: сохранить | Tab: следующее поле | Shift+Tab: предыдущее поле | Esc: выйти",
    )
    .style(Style::default().fg(theme.color("table_header")))
    .alignment(Alignment::Center);
    f.render_widget(help, chunks[2]);
}
##########################

####### src/ui/schedule.rs #########
use crate::app::App;
use ratatui::{prelude::*, text::ToText, widgets::*};

pub fn render(f: &mut Frame, app: &App, area: Rect) {
    let theme = app.theme();

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Min(1), Constraint::Length(3)])
        .split(area);

    render_schedule_table(f, app, chunks[0]);
    render_help(f, app, chunks[1]);
}

fn render_schedule_table(f: &mut Frame, app: &App, area: Rect) {
    let theme = app.theme();

    if app.schedules().is_empty() {
        let msg = Paragraph::new("Нет занятий на выбранную дату")
            .style(Style::default().fg(theme.color("highlight")))
            .alignment(Alignment::Center);
        f.render_widget(msg, area);
        return;
    }

    let rows: Vec<Row> = app
        .schedules()
        .iter()
        .flat_map(|s| {
            s.lessons.iter().map(|l| {
                Row::new(vec![
                    l.start_time.format("%H:%M").to_string(),
                    l.end_time.format("%H:%M").to_string(),
                    l.title.clone(),
                    l.cabinet.clone(),
                    l.teacher.clone(),
                ])
            })
        })
        .collect();

    let table = Table::new(
        rows,
        [
            Constraint::Percentage(12),
            Constraint::Percentage(12),
            Constraint::Percentage(45),
            Constraint::Percentage(15),
            Constraint::Percentage(16),
        ],
    )
    .header(
        Row::new(vec!["Нач", "Кон", "Предмет", "Каб", "Преп"])
            .style(Style::default().fg(theme.color("table_header"))),
    )
    .block(
        Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(theme.color("border")))
            .title("Расписание"),
    );

    f.render_widget(table, area);
}

fn render_help(f: &mut Frame, app: &App, area: Rect) {
    let theme = app.theme();
    let keymap = app.config.keymap();
    let help_text = format!(
        "{}: предыдущий день | {}: сегодня | {}: следующий день | {}: выбор группы | {}: настройки | {}: выход",
        keymap.prev_day.to_text(),
        keymap.cur_day.to_text(),
        keymap.next_day.to_text(),
        keymap.selector.to_text(),
        keymap.settings.to_text(),
        keymap.exit.to_text()
    );

    let help = Paragraph::new(help_text)
        .style(Style::default().fg(theme.color("table_header")))
        .alignment(Alignment::Center)
        .block(
            Block::default()
                .borders(Borders::TOP)
                .border_style(Style::default().fg(theme.color("border"))),
        );

    f.render_widget(help, area);
}
##########################

####### src/bin/osatui-gen-config.rs #########
use std::{
    path::{Path, PathBuf},
    str::FromStr,
};

use osatui::config::{main::MainConfig, theme::ThemeConfig};
use tokio::fs;
use toml;

#[tokio::main]
async fn main() {
    let example_main_config = toml::to_string_pretty(&MainConfig::default()).unwrap();
    let example_theme_config = toml::to_string_pretty(&ThemeConfig::default()).unwrap();
    let example_main_file = PathBuf::from_str("config.toml.example").unwrap();
    let example_theme_file = PathBuf::from_str("theme.toml.example").unwrap();
    fs::write(example_main_file, example_main_config)
        .await
        .unwrap();
    fs::write(example_theme_file, example_theme_config)
        .await
        .unwrap();
}
##########################

####### src/api/mod.rs #########
pub mod client;

pub use client::ApiClient;
##########################

####### src/api/client.rs #########
use crate::{
    cache::{self, CacheManager},
    config::Config,
    utils::date::AppDate,
};
use osars::{
    Client,
    models::{Campus, College, Group, Schedule},
};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

pub struct ApiClient {
    config: Config,
    client: Client,
    college_id: Option<u32>,
    campus_id: Option<u32>,
    group_id: Option<u32>,
    cache: Option<CacheManager>,
    lists_cache: HashMap<String, (Vec<u8>, u64)>,
}

impl ApiClient {
    pub async fn new(config: Config) -> anyhow::Result<Self> {
        let cache = if config.cache_enabled() {
            Some(CacheManager::new(config.cache_ttl()).await?)
        } else {
            None
        };

        let client = Client::new(config.api_url());
        let (college_id, campus_id, group_id) = Self::resolve_ids(&client, &config).await?;

        Ok(Self {
            config,
            client: client.with_college(college_id),
            college_id: Some(college_id),
            campus_id: Some(campus_id),
            group_id: Some(group_id),
            cache,
            lists_cache: HashMap::new(),
        })
    }

    pub async fn new_base(config: Config) -> anyhow::Result<Self> {
        let cache = if config.cache_enabled() {
            Some(CacheManager::new(config.cache_ttl()).await?)
        } else {
            None
        };

        Ok(Self {
            config: config.clone(),
            client: Client::new(config.api_url()),
            college_id: None,
            campus_id: None,
            group_id: None,
            cache,
            lists_cache: HashMap::new(),
        })
    }

    async fn resolve_ids(client: &Client, config: &Config) -> anyhow::Result<(u32, u32, u32)> {
        let college_id = if let Some(college_name) = config.college_name() {
            Self::find_college_id(client, college_name).await?
        } else {
            config.college_id()
        };

        let campus_id = if let Some(campus_name) = config.campus_name() {
            Self::find_campus_id(config.api_url(), college_id, campus_name).await?
        } else {
            config.campus_id()
        };

        let group_id = if let Some(group_name) = config.group_name() {
            Self::find_group_id(client, campus_id, group_name).await?
        } else {
            config.group_id()
        };

        Ok((college_id, campus_id, group_id))
    }

    async fn find_college_id(client: &Client, college_name: &str) -> anyhow::Result<u32> {
        let colleges: Vec<College> = client.colleges().name(college_name).send().await?;
        colleges
            .first()
            .map(|c| c.college_id)
            .ok_or_else(|| anyhow::anyhow!("Колледж с именем '{}' не найден", college_name))
    }

    async fn find_campus_id(
        api_url: &str,
        college_id: u32,
        campus_name: &str,
    ) -> anyhow::Result<u32> {
        let client = Client::new(api_url).with_college(college_id);
        let campuses: Vec<Campus> = client
            .campuses()
            .map_err(|_| anyhow::anyhow!("Не удалось создать запрос кампусов"))?
            .send()
            .await?;

        let campus = campuses
            .into_iter()
            .find(|c| c.name.to_lowercase().contains(&campus_name.to_lowercase()));

        campus.map(|c| c.id).ok_or_else(|| {
            anyhow::anyhow!(
                "Кампус с именем '{}' не найден в колледже {}",
                campus_name,
                college_id
            )
        })
    }

    async fn find_group_id(
        client: &Client,
        campus_id: u32,
        group_name: &str,
    ) -> anyhow::Result<u32> {
        let groups: Vec<Group> = client.groups(campus_id).name(group_name).send().await?;
        groups
            .first()
            .map(|g| g.id)
            .ok_or_else(|| anyhow::anyhow!("Группа с именем '{}' не найдена", group_name))
    }

    pub async fn get_colleges(&mut self) -> anyhow::Result<Vec<College>> {
        let cache_key = "colleges_list".to_string();
        if let Some((cached_data, timestamp)) = self.lists_cache.get(&cache_key) {
            let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
            if current_time - timestamp < 300 {
                return Ok(serde_json::from_slice(cached_data)?);
            }
        }

        let colleges = Client::new(self.config.api_url()).colleges().send().await?;
        let serialized = serde_json::to_vec(&colleges)?;
        let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        self.lists_cache.insert(cache_key, (serialized, timestamp));

        Ok(colleges)
    }

    pub async fn get_campuses(&mut self, college_id: u32) -> anyhow::Result<Vec<Campus>> {
        let cache_key = format!("campuses_list_{}", college_id);
        if let Some((cached_data, timestamp)) = self.lists_cache.get(&cache_key) {
            let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
            if current_time - timestamp < 300 {
                return Ok(serde_json::from_slice(cached_data)?);
            }
        }

        let client = Client::new(self.config.api_url()).with_college(college_id);
        let campuses = client
            .campuses()
            .map_err(|e| anyhow::anyhow!("Не удалось создать запрос кампусов: {}", e))?
            .send()
            .await?;

        let serialized = serde_json::to_vec(&campuses)?;
        let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        self.lists_cache.insert(cache_key, (serialized, timestamp));

        Ok(campuses)
    }

    pub async fn get_groups(&mut self, campus_id: u32) -> anyhow::Result<Vec<Group>> {
        let cache_key = format!("groups_list_{}", campus_id);
        if let Some((cached_data, timestamp)) = self.lists_cache.get(&cache_key) {
            let current_time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
            if current_time - timestamp < 300 {
                return Ok(serde_json::from_slice(cached_data)?);
            }
        }

        let groups = Client::new(self.config.api_url())
            .groups(campus_id)
            .send()
            .await?;
        let serialized = serde_json::to_vec(&groups)?;
        let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        self.lists_cache.insert(cache_key, (serialized, timestamp));

        Ok(groups)
    }

    pub async fn fetch(&self, date: &AppDate) -> anyhow::Result<Vec<Schedule>> {
        if let Some(cache) = &self.cache {
            if let Some(data) = cache.get(date).await? {
                return Ok(data);
            }
        }

        let group_id = self
            .group_id
            .ok_or_else(|| anyhow::anyhow!("Group ID not set"))?;
        let schedules = self
            .client
            .schedule(group_id)
            .date(&date.iso())
            .send()
            .await?;

        if let Some(cache) = &self.cache {
            let _ = cache.set(date, &schedules).await;
        }

        Ok(schedules)
    }

    pub fn college_id(&self) -> Option<u32> {
        self.college_id
    }

    pub fn campus_id(&self) -> Option<u32> {
        self.campus_id
    }

    pub fn group_id(&self) -> Option<u32> {
        self.group_id
    }

    pub async fn clear_cache(&mut self) -> anyhow::Result<()> {
        let cache = self.cache.as_mut().ok_or("Менеджер кеша не найден");
        match cache {
            Ok(c) => c.clear().await?,
            Err(e) => {
                return Err(anyhow::Error::msg(e));
            }
        }
        self.lists_cache.clear();
        Ok(())
    }
}
##########################

####### src/cache/mod.rs #########
pub mod manager;

pub use manager::CacheManager;
##########################

####### src/cache/manager.rs #########
use crate::utils::date::AppDate;
use osars::models::Schedule;
use std::path::PathBuf;

pub struct CacheManager {
    dir: PathBuf,
    ttl: u64,
}

impl CacheManager {
    pub async fn new(ttl: u64) -> anyhow::Result<Self> {
        let dir = dirs::cache_dir()
            .unwrap_or_else(|| ".".into())
            .join("osatui");
        tokio::fs::create_dir_all(&dir).await?;
        Ok(Self { dir, ttl })
    }

    pub async fn get(&self, date: &AppDate) -> anyhow::Result<Option<Vec<Schedule>>> {
        let path = self.dir.join(format!("{}.json", date.iso()));
        if !path.exists() {
            return Ok(None);
        }
        let content = tokio::fs::read_to_string(&path).await?;
        let data: Vec<Schedule> = serde_json::from_str(&content)?;
        Ok(Some(data))
    }

    pub async fn set(&self, date: &AppDate, data: &[Schedule]) -> anyhow::Result<()> {
        let path = self.dir.join(format!("{}.json", date.iso()));
        let content = serde_json::to_string_pretty(data)?;
        tokio::fs::write(&path, content).await?;
        Ok(())
    }

    pub async fn clear(&self) -> anyhow::Result<()> {
        if self.dir.exists() {
            for entry in std::fs::read_dir(&self.dir)? {
                let entry = entry?;
                if entry.path().extension().and_then(|s| s.to_str()) == Some("json") {
                    tokio::fs::remove_file(entry.path()).await?;
                }
            }
        }
        Ok(())
    }
}
##########################

####### src/lib.rs #########
pub mod api;
pub mod app;
pub mod cache;
pub mod config;
pub mod ui;
pub mod utils;
##########################

####### src/utils/mod.rs #########
pub mod date;

pub use date::AppDate;
##########################

####### src/utils/date.rs #########
use chrono::{Duration, NaiveDate, Utc};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct AppDate(NaiveDate);

impl AppDate {
    pub fn today() -> Self {
        Self(Utc::now().date_naive())
    }

    pub fn prev(self) -> Self {
        Self(self.0 - Duration::days(1))
    }

    pub fn next(self) -> Self {
        Self(self.0 + Duration::days(1))
    }

    pub fn format(&self) -> String {
        let today = Utc::now().date_naive();
        if self.0 == today {
            "Сегодня".into()
        } else if self.0 == today + Duration::days(1) {
            "Завтра".into()
        } else if self.0 == today - Duration::days(1) {
            "Вчера".into()
        } else {
            self.0.format("%d %B %Y").to_string()
        }
    }

    pub fn iso(&self) -> String {
        self.0.format("%d-%m-%Y").to_string()
    }
}
##########################

####### src/config/theme.rs #########
use log::debug;
use ratatui::style::Color;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Theme {
    pub background: String,
    pub text: String,
    pub header_bg: String,
    pub header_fg: String,
    pub table_header: String,
    pub border: String,
    pub highlight: String,
}

impl Theme {
    pub fn color(&self, field: &str) -> Color {
        let hex = match field {
            "background" => &self.background,
            "text" => &self.text,
            "header_bg" => &self.header_bg,
            "header_fg" => &self.header_fg,
            "table_header" => &self.table_header,
            "border" => &self.border,
            "highlight" => &self.highlight,
            _ => "#ffffff",
        };
        let hex = hex.trim_start_matches('#');
        let r = u8::from_str_radix(&hex[0..2], 16).unwrap_or(255);
        let g = u8::from_str_radix(&hex[2..4], 16).unwrap_or(255);
        let b = u8::from_str_radix(&hex[4..6], 16).unwrap_or(255);
        Color::Rgb(r, g, b)
    }
}

#[derive(Clone, Deserialize, Serialize)]
pub struct ThemeConfig(HashMap<String, Theme>);

impl ThemeConfig {
    pub async fn load() -> anyhow::Result<Self> {
        let path = dirs::config_dir()
            .unwrap_or_else(|| ".".into())
            .join("osatui/theme.toml");

        let mut s = String::new();
        if !path.exists() {
            Ok::<ThemeConfig, ()>(Self::default());
        } else {
            s = tokio::fs::read_to_string(path).await?;
        }

        let mut themes: HashMap<String, Theme> = toml::from_str(&s)?;
        if !themes.contains_key("dark") {
            themes.insert(
                "dark".into(),
                Theme {
                    background: "#1e1e1e".into(),
                    text: "#dcdcdc".into(),
                    header_bg: "#0064c8".into(),
                    header_fg: "#ffffff".into(),
                    table_header: "#ffff00".into(),
                    border: "#646464".into(),
                    highlight: "#00c800".into(),
                },
            );
        }
        Ok(Self(themes))
    }
    pub fn default() -> Self {
        let mut config: HashMap<String, Theme> = HashMap::new();
        config.insert(
            "dark".to_string(),
            Theme {
                background: "#1e1e1e".into(),
                text: "#dcdcdc".into(),
                header_bg: "#0064c8".into(),
                header_fg: "#ffffff".into(),
                table_header: "#ffff00".into(),
                border: "#646464".into(),
                highlight: "#00c800".into(),
            },
        );
        return Self(config);
    }

    pub fn get(&self, name: &str) -> &Theme {
        self.0.get(name).unwrap_or(&self.0["dark"])
    }
}
##########################

####### src/config/mod.rs #########
pub mod main;
pub mod theme;

use log::debug;
use ratatui::crossterm::event::KeyCode;
use serde::{Deserialize, Serialize};

use crate::config::main::KeyMap;

use self::{main::MainConfig, theme::ThemeConfig};

#[derive(Clone, Deserialize)]
pub struct Config {
    main: MainConfig,
    themes: ThemeConfig,
}

impl Config {
    pub async fn load() -> anyhow::Result<Self> {
        debug!("Loading main config");
        let main = MainConfig::load().await?;
        debug!("Main config loaded");
        debug!("Themes loading");
        let themes = ThemeConfig::load().await?;
        debug!("Themes loaded");
        Ok(Self { main, themes })
    }
    pub fn default() -> Self {
        let main = MainConfig::default();
        let themes = ThemeConfig::default();
        Self { main, themes }
    }

    pub async fn save(&self) -> anyhow::Result<()> {
        self.main.save().await
    }

    pub fn api_url(&self) -> &str {
        &self.main.api.url
    }
    pub fn college_id(&self) -> u32 {
        self.main.api.college_id
    }
    pub fn college_name(&self) -> Option<&str> {
        self.main.api.college_name.as_deref()
    }
    pub fn campus_id(&self) -> u32 {
        self.main.api.campus_id
    }
    pub fn campus_name(&self) -> Option<&str> {
        self.main.api.campus_name.as_deref()
    }
    pub fn group_id(&self) -> u32 {
        self.main.api.group_id
    }
    pub fn group_name(&self) -> Option<&str> {
        self.main.api.group_name.as_deref()
    }
    pub fn cache_enabled(&self) -> bool {
        self.main.app.cache_enabled
    }
    pub fn cache_ttl(&self) -> u64 {
        self.main.app.cache_ttl
    }
    pub fn current_theme(&self) -> &str {
        &self.main.app.current_theme
    }
    pub fn theme(&self) -> &theme::Theme {
        self.themes.get(self.current_theme())
    }

    pub fn set_api_url(&mut self, url: String) {
        self.main.api.url = url.trim_end_matches('/').to_string();
    }

    pub fn set_college(&mut self, id: u32, name: Option<String>) {
        self.main.api.college_id = id;
        self.main.api.college_name = name;
    }

    pub fn set_campus(&mut self, id: u32, name: Option<String>) {
        self.main.api.campus_id = id;
        self.main.api.campus_name = name;
    }

    pub fn set_group(&mut self, id: u32, name: Option<String>) {
        self.main.api.group_id = id;
        self.main.api.group_name = name;
    }
    pub fn keymap(&self) -> KeyMap {
        self.main.keymap
    }
}
##########################

####### src/config/main.rs #########
use crossterm::event::KeyCode;
use log::{info, warn};
use serde::{Deserialize, Serialize};
use tokio::fs;

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Api {
    pub url: String,
    pub college_id: u32,
    pub college_name: Option<String>,
    pub campus_id: u32,
    pub campus_name: Option<String>,
    pub group_id: u32,
    pub group_name: Option<String>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct App {
    pub refresh_interval: u64,
    pub cache_enabled: bool,
    pub cache_ttl: u64,
    pub current_theme: String,
}

#[derive(Debug, Deserialize, Serialize, Clone, Copy)]
pub struct KeyMap {
    pub prev_day: KeyCode,
    pub cur_day: KeyCode,
    pub next_day: KeyCode,
    pub selector: KeyCode,
    pub settings: KeyCode,
    pub exit: KeyCode,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct MainConfig {
    #[serde(rename = "api")]
    pub api: Api,
    #[serde(rename = "app")]
    pub app: App,
    #[serde(rename = "keymap")]
    pub keymap: KeyMap,
}

impl MainConfig {
    pub async fn load() -> anyhow::Result<Self> {
        let path = Self::config_path();

        if path.exists() {
            info!("config founded");
            let s = tokio::fs::read_to_string(&path).await?;
            let mut cfg: Self = toml::from_str(&s)?;
            cfg.api.url = cfg.api.url.trim_end_matches('/').to_string();
            Ok(cfg)
        } else {
            warn!("config not founded use default");
            let default_config = Self::default();
            default_config.save().await?;
            Ok(default_config)
        }
    }

    pub async fn save(&self) -> anyhow::Result<()> {
        let path = Self::config_path();
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).await?;
        }

        let toml = toml::to_string_pretty(self)?;
        fs::write(&path, toml).await?;
        Ok(())
    }

    fn config_path() -> std::path::PathBuf {
        dirs::config_dir()
            .unwrap_or_else(|| ".".into())
            .join("osatui/config.toml")
    }

    pub fn default() -> Self {
        Self {
            api: Api {
                url: "https://api.thisishyum.ru/schedule_api/tymen".to_string(),
                college_id: 1,
                college_name: None,
                campus_id: 1,
                campus_name: None,
                group_id: 1,
                group_name: None,
            },
            app: App {
                refresh_interval: 300,
                cache_enabled: true,
                cache_ttl: 3600,
                current_theme: "dark".to_string(),
            },
            keymap: KeyMap {
                prev_day: KeyCode::Left,
                cur_day: KeyCode::Up,
                next_day: KeyCode::Right,
                selector: KeyCode::Char('o'),
                settings: KeyCode::Char('s'),
                exit: KeyCode::Char('q'),
            },
        }
    }
}
##########################

####### src/main.rs #########
use crossterm::{
    ExecutableCommand,
    event::{self, Event, KeyCode, KeyEventKind, KeyModifiers},
    terminal::{EnterAlternateScreen, LeaveAlternateScreen, disable_raw_mode, enable_raw_mode},
};
use log::{debug, error, info, warn};
use osatui::app::App;
use osatui::{app, ui};
use osatui::{cache::CacheManager, config::main::KeyMap};
use ratatui::{Terminal, backend::CrosstermBackend};
use std::io;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    pretty_env_logger::init();
    info!("Loading osatui");
    let config = osatui::config::Config::load().await?;
    info!("Config loaded");
    debug!("API url: {}", config.api_url());
    let mut app = App::new(config.clone()).await?;

    enable_raw_mode()?;
    let mut stdout = io::stdout();
    stdout.execute(EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    let keymap: KeyMap = config.keymap();
    loop {
        terminal.draw(|f| ui::render(f, &app))?;

        if event::poll(std::time::Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match app.mode() {
                        app::AppMode::Normal => match key.code {
                            kc if kc == keymap.exit => app.quit(),
                            kc if kc == keymap.settings => {
                                app.start_setup();
                            }
                            kc if kc == keymap.selector => {
                                if let Err(e) = app.start_selector().await {
                                    eprintln!("Ошибка запуска селектора: {}", e);
                                }
                            }
                            KeyCode::Char('r') if key.modifiers.contains(KeyModifiers::SHIFT) => {
                                if let Err(e) = app.reload_cache().await {
                                    eprintln!("Ошибка перезагрузки кеша: {}", e);
                                }
                            }
                            kc if kc == keymap.prev_day => {
                                if let Err(e) = app.prev_day().await {
                                    eprintln!("Ошибка перехода к предыдущему дню: {}", e);
                                }
                            }
                            kc if kc == keymap.cur_day => {
                                if let Err(e) = app.go_today().await {
                                    eprintln!("Ошибка перехода к сегодняшнему дню: {}", e);
                                }
                            }
                            kc if kc == keymap.next_day => {
                                if let Err(e) = app.next_day().await {
                                    eprintln!("Ошибка перехода к следующему дню: {}", e);
                                }
                            }
                            _ => {}
                        },
                        app::AppMode::Setup(_) => {}
                        app::AppMode::Selector(_) => match key.code {
                            KeyCode::Enter => {
                                if let Err(e) = app.handle_selector_input().await {
                                    eprintln!("Ошибка обработки выбора: {}", e);
                                }
                            }
                            KeyCode::Down | KeyCode::Up | KeyCode::Right | KeyCode::Left => {
                                app.handle_selector_navigation(key.code).await;
                            }
                            KeyCode::Esc => {
                                *app.mode_mut() = app::AppMode::Normal;
                            }
                            _ => {}
                        },
                    }
                }
            }
        }

        if app.should_quit() {
            break;
        }
    }

    disable_raw_mode()?;
    terminal.backend_mut().execute(LeaveAlternateScreen)?;
    Ok(())
}
##########################

####### src/app.rs #########
use crate::{
    api::ApiClient,
    cache::{self, CacheManager},
    config::Config,
    ui::{
        selector::{SelectionStage, SelectorState},
        setup::SetupState,
    },
    utils::AppDate,
};
use crossterm::event::KeyCode;
use osars::models::Schedule;

pub enum AppMode {
    Normal,
    Setup(SetupState),
    Selector(SelectorState),
}

pub struct App {
    pub config: Config,
    api: Option<ApiClient>,
    schedules: Vec<Schedule>,
    date: AppDate,
    should_quit: bool,
    mode: AppMode,
}

impl App {
    pub async fn new(config: Config) -> anyhow::Result<Self> {
        match ApiClient::new(config.clone()).await {
            Ok(mut api) => {
                let date = AppDate::today();
                let mut schedules = api.fetch(&date).await?;
                if schedules[0].group_id != config.group_id() {
                    api.clear_cache().await?;
                    schedules = api.fetch(&date).await?;
                }
                Ok(Self {
                    config,
                    api: Some(api),
                    schedules,
                    date,
                    should_quit: false,
                    mode: AppMode::Normal,
                })
            }
            Err(e) => {
                eprintln!("Ошибка инициализации: {}. Запуск селектора...", e);
                let base_client = ApiClient::new_base(config.clone()).await?;
                let mut app = Self {
                    config,
                    api: Some(base_client),
                    schedules: Vec::new(),
                    date: AppDate::today(),
                    should_quit: false,
                    mode: AppMode::Selector(SelectorState::new()),
                };
                app.load_colleges().await?;
                Ok(app)
            }
        }
    }

    async fn load_colleges(&mut self) -> anyhow::Result<()> {
        if let (AppMode::Selector(selector), Some(api)) = (&mut self.mode, &mut self.api) {
            match api.get_colleges().await {
                Ok(colleges) => {
                    selector.colleges = colleges;
                    if selector.colleges.is_empty() {
                        selector.error_message =
                            Some("Список колледжей пуст. Проверьте URL API.".to_string());
                    }
                }
                Err(e) => {
                    selector.error_message = Some(format!("Ошибка загрузки колледжей: {}", e));
                }
            }
        }
        Ok(())
    }

    async fn load_campuses(&mut self, college_id: u32) -> anyhow::Result<()> {
        if let (AppMode::Selector(selector), Some(api)) = (&mut self.mode, &mut self.api) {
            match api.get_campuses(college_id).await {
                Ok(campuses) => {
                    selector.campuses = campuses;
                    if selector.campuses.is_empty() {
                        selector.error_message = Some("Список кампусов пуст.".to_string());
                    }
                }
                Err(e) => {
                    selector.error_message = Some(format!("Ошибка загрузки кампусов: {}", e));
                }
            }
        }
        Ok(())
    }

    async fn load_groups(&mut self, campus_id: u32) -> anyhow::Result<()> {
        if let (AppMode::Selector(selector), Some(api)) = (&mut self.mode, &mut self.api) {
            match api.get_groups(campus_id).await {
                Ok(groups) => {
                    selector.groups = groups;
                    if selector.groups.is_empty() {
                        selector.error_message = Some("Список групп пуст.".to_string());
                    }
                }
                Err(e) => {
                    selector.error_message = Some(format!("Ошибка загрузки групп: {}", e));
                }
            }
        }
        Ok(())
    }

    pub async fn reload_cache(&mut self) -> anyhow::Result<()> {
        if let Some(api) = &mut self.api {
            api.clear_cache().await?;

            self.schedules = api.fetch(&self.date).await?;
            println!("Кеш успешно очищен и перезагружен");
        }
        Ok(())
    }

    pub fn start_setup(&mut self) {
        let mut state = SetupState::new();
        state.api_url = self.config.api_url().to_string();
        state.college_id = self.config.college_id().to_string();
        state.campus_id = self.config.campus_id().to_string();
        state.group_name = self.config.group_name().unwrap_or("").to_string();
        self.mode = AppMode::Setup(state);
    }

    pub async fn start_selector(&mut self) -> anyhow::Result<()> {
        let api = ApiClient::new_base(self.config.clone()).await?;
        self.api = Some(api);
        self.mode = AppMode::Selector(SelectorState::new());
        self.load_colleges().await?;
        Ok(())
    }

    pub async fn handle_selector_input(&mut self) -> anyhow::Result<()> {
        if let AppMode::Selector(selector) = &mut self.mode {
            match selector.stage {
                SelectionStage::College => {
                    if let Some(college) = selector.get_selected_college().cloned() {
                        let college_id = college.college_id;
                        selector.selected_college = Some(college);
                        selector.stage = SelectionStage::Campus;
                        selector.reset_pagination();
                        selector.error_message = None;
                        self.load_campuses(college_id).await?;
                    }
                }
                SelectionStage::Campus => {
                    if let Some(campus) = selector.get_selected_campus().cloned() {
                        let campus_id = campus.id;
                        selector.selected_campus = Some(campus);
                        selector.stage = SelectionStage::Group;
                        selector.reset_pagination();
                        selector.error_message = None;
                        self.load_groups(campus_id).await?;
                    }
                }
                SelectionStage::Group => {
                    if let Some(group) = selector.get_selected_group() {
                        if let Some(college) = &selector.selected_college {
                            self.config
                                .set_college(college.college_id, Some(college.name.clone()));
                        }
                        if let Some(campus) = &selector.selected_campus {
                            self.config.set_campus(campus.id, Some(campus.name.clone()));
                        }
                        self.config.set_group(group.id, Some(group.name.clone()));
                        self.config.save().await?;
                        self.api = Some(ApiClient::new(self.config.clone()).await?);
                        self.schedules = self.api.as_ref().unwrap().fetch(&self.date).await?;
                        self.mode = AppMode::Normal;
                    }
                }
            }
        }
        Ok(())
    }

    pub async fn handle_selector_navigation(&mut self, key: KeyCode) {
        if let AppMode::Selector(selector) = &mut self.mode {
            match key {
                KeyCode::Down => selector.next_item(),
                KeyCode::Up => selector.prev_item(),
                KeyCode::Right => selector.next_page(),
                KeyCode::Left => selector.prev_page(),
                _ => {}
            }
        }
    }

    pub async fn handle_setup_input(&mut self, _input: char) -> anyhow::Result<()> {
        Ok(())
    }

    pub async fn prev_day(&mut self) -> anyhow::Result<()> {
        if let (AppMode::Normal, Some(api)) = (&self.mode, &self.api) {
            self.date = self.date.prev();
            self.schedules = api.fetch(&self.date).await?;
        }
        Ok(())
    }

    pub async fn next_day(&mut self) -> anyhow::Result<()> {
        if let (AppMode::Normal, Some(api)) = (&self.mode, &self.api) {
            self.date = self.date.next();
            self.schedules = api.fetch(&self.date).await?;
        }
        Ok(())
    }

    pub async fn go_today(&mut self) -> anyhow::Result<()> {
        if let (AppMode::Normal, Some(api)) = (&self.mode, &self.api) {
            self.date = AppDate::today();
            self.schedules = api.fetch(&self.date).await?;
        }
        Ok(())
    }

    pub fn quit(&mut self) {
        self.should_quit = true;
    }

    pub fn should_quit(&self) -> bool {
        self.should_quit
    }

    pub fn date(&self) -> &AppDate {
        &self.date
    }

    pub fn schedules(&self) -> &[Schedule] {
        &self.schedules
    }

    pub fn theme(&self) -> &crate::config::theme::Theme {
        self.config.theme()
    }

    pub fn mode(&self) -> &AppMode {
        &self.mode
    }

    pub fn mode_mut(&mut self) -> &mut AppMode {
        &mut self.mode
    }
}
##########################

